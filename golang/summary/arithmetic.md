[toc]

# 动态规划

动态规划（Dynamic programming，简称DP）



能用动态规划解决的前提：

* 大规模问题的答案可以由小规模问题的答案递推得到
* 问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列



应用动态规划步骤

1. **建立状态转移方程**

   比如当已经知道`f(1)~f(n-1)`的值，然后想办法利用它们求得`f(n)` ，状态转移方程就像 `f(n) = f(n-1) + 2`

2. **缓存并复用以往结果**

   如果现在`f(100)`未知，但是刚刚求解过一次`f(99)`。如果不将其缓存起来，那么求`f(100)` 时，我们就必须花100次加法运算重新获取。但是如果刚刚缓存过，只需复用这个子结果，那么将只需一次加法运算即可。

3. **按顺序从小往大算**

   小”和“大”对应的是问题的规模，在这里也就是我们要从 `f(0)`,`f(1)`  , ... 到`f(n)` 依次顺序计算。状态方程基本限制了你只能从小到大一步步递推出最终的结果（假设我们仍然不能用显式方程）

   



斐波那契数列

状态转移方程为`f(n) = f(n-1) + f(n-2)`，如果用递归，是这样的：

```go
// FibonacciRE 返回斐波那契数列中第n个数
// 递归实现,为了对比动态规划
func FibonacciRE(n int) int {
	if n < 2 {
		return n
	}

	return FibonacciRE(n-1) + FibonacciRE(n-2)
}
```

用动态规划：

```go
// FibonacciDP 返回斐波那契数列中第n个数
// 动态规划实现
func FibonacciDP(n int) int {
	dp := make([]int, n) // 用于缓存以往结果，以便复用
	dp[0] = 1
	dp[1] = 1

	// 按顺序从小往大算
	for i := 2; i < n; i++ {
		// 使用状态转移方程，同时复用以往结果
		dp[i] = dp[i-1] + dp[i-2]
	}

	return dp[n-1]
}
```



参考：

https://www.zhihu.com/question/39948290



# 贪心算法

贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。



